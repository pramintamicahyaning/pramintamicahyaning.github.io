{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SELAMAT DATANG \u00b6 Nama : Pramintami Cahyaning S M Jurusan : Informatika Nim : 180411100011","title":"Beranda"},{"location":"#selamat-datang","text":"Nama : Pramintami Cahyaning S M Jurusan : Informatika Nim : 180411100011","title":"SELAMAT DATANG"},{"location":"DERETMacLaurin/","text":"DERET MacLaurin \u00b6 DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Atau bisa dinyatakan dengan: Perhitungan e^2x \u00b6 Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x)=exf(x)=ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e2xe2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99. Listing Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x=4 cek =1 a = 0 b=1 iter = 1 while cek>0.001: f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) cek = f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",cek) iter+=1 output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Tugas 1"},{"location":"DERETMacLaurin/#deret-maclaurin","text":"DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Atau bisa dinyatakan dengan:","title":"DERET MacLaurin"},{"location":"DERETMacLaurin/#perhitungan-e2x","text":"Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x)=exf(x)=ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e2xe2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99.","title":"Perhitungan e^2x"},{"location":"DERETMacLaurin/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x=4 cek =1 a = 0 b=1 iter = 1 while cek>0.001: f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) cek = f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",cek) iter+=1 output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Listing Program"},{"location":"EULER/","text":"METHODE EULER \u00b6 \u200b Metode Euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerikk persamaan diferensial biasa dan merupakan metode Runge-Kutta paing sederhana. Metode Euler dinamai Leonhard Euler, yang memperlakukannya dalam bukunya Institutionum Calculi Integralis yang diterbitkan pada tahun 1768-1870. \u200b Metode Euler adalah metode tingkat pertama, yang berarti bahwa kesalahan lokal(per langkah) sebanding dengan kuadrat urutan langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya metode prediktor-korektor . Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dydx=f(x,y)y=dydx=f(x,y) dan nilai awal y(x0)=y0y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xnh=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hyn+1=yn+h x f(xn,yn)f(xn,yn) SOAL \u00b6 Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: import numpy as np #Parameter untuk Euler y0 = -4 x0 = float(input(\"masukkan nilai x0 :\")) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range(1,n): hasil = y0 + h*(1 + (x0) ** 2) x0 += h y0 = hasil print(\"Langkah\"+str(i)+\": y\"+str(i)+\"= \"+ str(hasil)) Hasil Running \u00b6 masukkan nilai x0 :1 Langkah1: y1= -3.98 Langkah2: y2= -3.959799 Langkah3: y3= -3.9393949999999998 Process finished with exit code 0","title":"Tugas 6"},{"location":"EULER/#methode-euler","text":"\u200b Metode Euler adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerikk persamaan diferensial biasa dan merupakan metode Runge-Kutta paing sederhana. Metode Euler dinamai Leonhard Euler, yang memperlakukannya dalam bukunya Institutionum Calculi Integralis yang diterbitkan pada tahun 1768-1870. \u200b Metode Euler adalah metode tingkat pertama, yang berarti bahwa kesalahan lokal(per langkah) sebanding dengan kuadrat urutan langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya metode prediktor-korektor . Misalnya diberikan Persamaan Diferensial Biasa orde satu, y=dydx=f(x,y)y=dydx=f(x,y) dan nilai awal y(x0)=y0y(x0)=y0 Dengan langkah h didefinisikan sebagai h=xn+1\u2212xnh=xn+1\u2212xn Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis yn+1=yn+hyn+1=yn+h x f(xn,yn)f(xn,yn)","title":"METHODE EULER"},{"location":"EULER/#soal","text":"Gunakan metode Euler untuk menyelesaikan Persamaan Diferensial Biasa: import numpy as np #Parameter untuk Euler y0 = -4 x0 = float(input(\"masukkan nilai x0 :\")) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range(1,n): hasil = y0 + h*(1 + (x0) ** 2) x0 += h y0 = hasil print(\"Langkah\"+str(i)+\": y\"+str(i)+\"= \"+ str(hasil))","title":"SOAL"},{"location":"EULER/#hasil-running","text":"masukkan nilai x0 :1 Langkah1: y1= -3.98 Langkah2: y2= -3.959799 Langkah3: y3= -3.9393949999999998 Process finished with exit code 0","title":"Hasil Running"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/","text":"ELIMINASI GAUSS, GAUS JACOBI DAN GAUSS SEIDEL \u00b6 Eliminasi Gauss \u00b6 Eliminasi Gauss adalah algoritma yang digunakan untuk menyelesaikan sistem persamaan linier. Metode inni dinamai dari matematikawan Carl Friedrich Gauss(1777-1855).Metode ini dapat dimanfaatkan untuk memecahkan sistem persamaan linier dengan mempresentasikan (mengubah) menjadi bentuk matriks, matriks tersebut lalu diubah kebentuk Eselon Baris melalui Operasi Baris Elementer, kemudian sistem diselesaikan dengan substitusi balik. Terdapat tiga jenis operasi yang dapat dilakukan dalam metode ini: Mengganti urutan dua baris mengalikan baris dengan angka yang bukan nol menambah suatu baris dengan baris yang lainnya dengan cara ini, matriks dapat dirubah menjadi matriks segitiga atas. Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int(input(\"Tentukan ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen Matrix: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Substitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0 Eliminasi Gaus Jacobi \u00b6 Metode Jacobi adalah metode tak langsung atau metode iteratif yang melakukan permbaharuan nilai x yang diperoleh tiap iterasi(mirip metode substitusi berurutan). Metode ini merupakan suatu teknik penyelesaian SPL berukuran n*n, AX=b, secara iteratif. Proses penyelesaian dimuali dengan suatu hampiran awal terhadap penyelesain, Xo, kemudian membentuk suatu serangkaian vector X1,X2,... yang konvergen ke X.\\ Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterais jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nol nya besar. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167]) Eliminasi Gaus Seidel \u00b6 Metode Gauss-Seidel digunakan utnuk menyelesaikan sistem persamaan linier berukuran besar dan proporsi koefisien nol-nya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan presentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0]","title":"Tugas 3"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gauss-gaus-jacobi-dan-gauss-seidel","text":"","title":"ELIMINASI GAUSS, GAUS JACOBI DAN GAUSS SEIDEL"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gauss","text":"Eliminasi Gauss adalah algoritma yang digunakan untuk menyelesaikan sistem persamaan linier. Metode inni dinamai dari matematikawan Carl Friedrich Gauss(1777-1855).Metode ini dapat dimanfaatkan untuk memecahkan sistem persamaan linier dengan mempresentasikan (mengubah) menjadi bentuk matriks, matriks tersebut lalu diubah kebentuk Eselon Baris melalui Operasi Baris Elementer, kemudian sistem diselesaikan dengan substitusi balik. Terdapat tiga jenis operasi yang dapat dilakukan dalam metode ini: Mengganti urutan dua baris mengalikan baris dengan angka yang bukan nol menambah suatu baris dengan baris yang lainnya dengan cara ini, matriks dapat dirubah menjadi matriks segitiga atas. Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int(input(\"Tentukan ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen Matrix: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Substitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0","title":"Eliminasi Gauss"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gaus-jacobi","text":"Metode Jacobi adalah metode tak langsung atau metode iteratif yang melakukan permbaharuan nilai x yang diperoleh tiap iterasi(mirip metode substitusi berurutan). Metode ini merupakan suatu teknik penyelesaian SPL berukuran n*n, AX=b, secara iteratif. Proses penyelesaian dimuali dengan suatu hampiran awal terhadap penyelesain, Xo, kemudian membentuk suatu serangkaian vector X1,X2,... yang konvergen ke X.\\ Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterais jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nol nya besar. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167])","title":"Eliminasi Gaus Jacobi"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gaus-seidel","text":"Metode Gauss-Seidel digunakan utnuk menyelesaikan sistem persamaan linier berukuran besar dan proporsi koefisien nol-nya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan presentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0]","title":"Eliminasi Gaus Seidel"},{"location":"MonteCarloMethod/","text":"Tugas 7 \u00b6 Metode Monte Carlo ( Monte Carlo Method ) \u00b6 Metode Monte Carlo adalah algoritma komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games, arsitektur, perancangan, film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. Metode Monte Carlo digunakan dengan istilah sampling statistik . Penggunaan nama Monte Carlo , yang dipopulerkan oleh para pioner bidang tersebut (termasuk Stanislaw Marcin Ulam, Enrico Fermi, John von Neumann dan Nicholas Metropolis, merupakan nama kasino terkemuka di Monako. Penggunaan keacakan dan sifat pengulangan proses mirip dengan aktivitas yang dilakukan pada sebuah kasino. Dalam autobiografinya Adventures of a Mathematician , Stanislaw Marcin Ulam menyatakan bahwa metode tersebut dinamakan untuk menghormati pamannya yang seorang penjudi, atas saran Metropolis. Penggunaannya yang cukup dikenal adalah oleh Enrico Fermi pada tahun 1930, ketika ia menggunakan metode acak untuk menghitung sifat-sifat neutron yang waktu itu baru saja ditemukan. Metode Monte Carlo merupakan simulasi inti yang digunakan dalam Manhattan Project, meski waktu itu masih menggunakan oleh peralatan komputasi yang sangat sederhana. Sejak digunakannya komputer elektronik pada tahun 1945, Monte Carlo mulai dipelajari secara mendalam. Pada tahun 1950-an, metode ini digunakan di Laboratorium Nasional Los Alamos untuk penelitian awal pengembangan bom hidrogen, dan kemudian sangat populer dalam bidang fisika dan riset operasi. *Rand Corporation]]*an Angkatan Udara AS merupakan dua institusi utama yang bertanggung jawab dalam pendanaan dan penyebaran informasi mengenai Monte Carlo waktu itu, dan mereka mulai menemukan aplikasinya dalam berbagai bidang. Penggunaan metode Monte Carlo memerlukan sejumlah besar bilangan acak, dan hal tersebut semakin mudah dengan perkembangan pembangkit bilangan pseudoacak, yang jauh lebih cepat dan praktis dibandingkan dengan metode sebelumnya yang menggunakan tabel bilangan acak untuk sampling statistik. Soal \u00b6 Listing Program 1 No 3 \u00b6 from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() Percobaan pertama Pada percobaan pertama Nilai Phi menunjukkan X=3.14465 y=255.824 Percobaan kedua Pada percobaan kedua Nilai Phi menunjukkan x=3.14118 y=286.582 Percobaan ketiga Pada percobaan ketiga Nilai Phi menunjukkan x=3.13834 y=245.591 Listing Program 2 No 4 \u00b6 from scipy import random #import library random dari scipy import numpy as np #import library numpy a = -1 b = 1 N=100 n=3 xrand=np.zeros(N)#dx yrand=np.zeros(N)#dy zrand=np.zeros(N)#dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jwb=(b-a)/float(N)*integral print(\"Hasil : \",jwb) Output #Percobaan 1 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.889285659898637 Process finished with exit code 0 #Percobaan 2 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 8.02539169028922 Process finished with exit code 0 #Percobaan 3 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.900022095053624 Process finished with exit code 0 Manual Kesimpulannya jika dibandingan dengan perhitungan manual hasil dari itegral dengan metode monte carlo hampir mendekati dan bahkan sama hasilnya.","title":"Tugas 7"},{"location":"MonteCarloMethod/#tugas-7","text":"","title":"Tugas 7"},{"location":"MonteCarloMethod/#metode-monte-carlo-monte-carlo-method","text":"Metode Monte Carlo adalah algoritma komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games, arsitektur, perancangan, film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. Metode Monte Carlo digunakan dengan istilah sampling statistik . Penggunaan nama Monte Carlo , yang dipopulerkan oleh para pioner bidang tersebut (termasuk Stanislaw Marcin Ulam, Enrico Fermi, John von Neumann dan Nicholas Metropolis, merupakan nama kasino terkemuka di Monako. Penggunaan keacakan dan sifat pengulangan proses mirip dengan aktivitas yang dilakukan pada sebuah kasino. Dalam autobiografinya Adventures of a Mathematician , Stanislaw Marcin Ulam menyatakan bahwa metode tersebut dinamakan untuk menghormati pamannya yang seorang penjudi, atas saran Metropolis. Penggunaannya yang cukup dikenal adalah oleh Enrico Fermi pada tahun 1930, ketika ia menggunakan metode acak untuk menghitung sifat-sifat neutron yang waktu itu baru saja ditemukan. Metode Monte Carlo merupakan simulasi inti yang digunakan dalam Manhattan Project, meski waktu itu masih menggunakan oleh peralatan komputasi yang sangat sederhana. Sejak digunakannya komputer elektronik pada tahun 1945, Monte Carlo mulai dipelajari secara mendalam. Pada tahun 1950-an, metode ini digunakan di Laboratorium Nasional Los Alamos untuk penelitian awal pengembangan bom hidrogen, dan kemudian sangat populer dalam bidang fisika dan riset operasi. *Rand Corporation]]*an Angkatan Udara AS merupakan dua institusi utama yang bertanggung jawab dalam pendanaan dan penyebaran informasi mengenai Monte Carlo waktu itu, dan mereka mulai menemukan aplikasinya dalam berbagai bidang. Penggunaan metode Monte Carlo memerlukan sejumlah besar bilangan acak, dan hal tersebut semakin mudah dengan perkembangan pembangkit bilangan pseudoacak, yang jauh lebih cepat dan praktis dibandingkan dengan metode sebelumnya yang menggunakan tabel bilangan acak untuk sampling statistik.","title":"Metode Monte Carlo (Monte Carlo Method)"},{"location":"MonteCarloMethod/#soal","text":"","title":"Soal"},{"location":"MonteCarloMethod/#listing-program-1-no-3","text":"from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Nilai phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() Percobaan pertama Pada percobaan pertama Nilai Phi menunjukkan X=3.14465 y=255.824 Percobaan kedua Pada percobaan kedua Nilai Phi menunjukkan x=3.14118 y=286.582 Percobaan ketiga Pada percobaan ketiga Nilai Phi menunjukkan x=3.13834 y=245.591","title":"Listing Program 1 No 3"},{"location":"MonteCarloMethod/#listing-program-2-no-4","text":"from scipy import random #import library random dari scipy import numpy as np #import library numpy a = -1 b = 1 N=100 n=3 xrand=np.zeros(N)#dx yrand=np.zeros(N)#dy zrand=np.zeros(N)#dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral=0.0 for i in range(n+1): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jwb=(b-a)/float(N)*integral print(\"Hasil : \",jwb) Output #Percobaan 1 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.889285659898637 Process finished with exit code 0 #Percobaan 2 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 8.02539169028922 Process finished with exit code 0 #Percobaan 3 C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\python.exe \"D:/Tugas Kuliah/Semester 4/Komnum/MonteCarlo 2.py\" Hasil : 7.900022095053624 Process finished with exit code 0 Manual Kesimpulannya jika dibandingan dengan perhitungan manual hasil dari itegral dengan metode monte carlo hampir mendekati dan bahkan sama hasilnya.","title":"Listing Program 2 No 4"},{"location":"NewtonRaphson/","text":"Program Newton Raphson pada Fungsi Non Linear \u00b6 Newton Raphson \u00b6 adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Implementasi Pemrograman \u00b6 dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Tugas 2"},{"location":"NewtonRaphson/#program-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Newton Raphson pada Fungsi Non Linear"},{"location":"NewtonRaphson/#newton-raphson","text":"adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})}","title":"Newton Raphson"},{"location":"NewtonRaphson/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"NewtonRaphson/#implementasi-pemrograman","text":"dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Implementasi Pemrograman"},{"location":"RecrusiveTrapezoid/","text":"INTEGRASI NUMERIK \u00b6 Metode Integrasi Numerik adalah salah satu cara untuk menghitung aproksimasi luas daerah di bawah fungsi yang dimaksud pada selang yang diberikan. Ada beberapa metode integrasi numerik yang lazim digunakan, diantaranya yaitu: Metode Euler Eksplisit Metode Euler Implisit pada metode integrasi implisit nilai aktual Xk juga digunakan sebagai umpan balik. Umpan balik ini dapat menyebabkan terjadinya lingkaran aljabar. untuk menghindarinya maka bentuk persamaan diubah menjadi seperti ini. METODE TRAPEZOID Aturan Trapezoid adalah suatu metode pendekatan integral numerik dengan polinomade satu. Metode trapezoid ini dapat diturunkan dengan substitusi fungsi Lagrange orde-1 sebagai f(x) yaitu: dengan demikian dapat dirumuskan: Dimana R adalah suku yang mengandung error komputasi O(h3). Sehingga kita mendapatkan rumus integral trapezoid yaitu: Dalam matematika , dan lebih khusus lagi dalam analisis numerik, aturan trapesium (juga dikenal sebagai Trapezoid Rule ) adalah teknik untuk mendekati integral yang pasti. Estimasi berdasarkan 1 Interval \u00b6 Algoritma Integral Trapezoida \u00b6 Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung Listing Program #definisi fungsi def fungsi (x): y = 1/(1+x) return y print(\"fungsi yang digunakan adalah\") print(\"\") print(\"\\t\\t\",\"f(x) = 1/(1+x)\") print(\"\") a = float(input(\"masukkan batas bawah integral : \")) b = float(input(\"masukkan batas atas integral : \")) c = int(input(\"masukkan n : \")) eror = [] print(\"\") print(\"----------------Hasil Integrasi-----------------\") print(\"iterasi\",\"\\t\",\"n\",\"\\t\\t\",\"Trapezoid\") for iterasi in range (0,c): n = 2**iterasi h = (b-a)/n xi = a y = 0 for i in range (1,n): xi = xi + h y += fungsi(xi) trap = ((h)*(fungsi(a) + (2*y) + fungsi(b)))/2 eror.append(trap) print (iterasi+1,\"\\t\\t\",n,\"\\t\\t\",trap) print (eror[iterasi-1]) print(eror[iterasi]) hasil = (eror[iterasi-1]-eror[iterasi]) print(hasil) print (\"estimasi error : \"+str(hasil)) \u200b hasil code fungsi yang digunakan adalah f(x) = 1/(1+x) masukkan batas bawah integral : 18 masukkan batas atas integral : 2 masukkan n : 10 ----------------Hasil Integrasi----------------- iterasi n Trapezoid 1 1 -3.087719298245614 2 2 -2.271132376395534 3 4 -1.9736614262930052 4 8 -1.880546148038408 5 16 -1.854757201003331 6 32 -1.8480774518918412 7 64 -1.846390566377457 8 128 -1.8459677344642065 9 256 -1.8458619561915175 10 512 -1.8458355072157113 -1.8458619561915175 -1.8458355072157113 -2.644897580617034e-05 estimasi error : -2.644897580617034e-05 \u200b","title":"Tugas 4"},{"location":"RecrusiveTrapezoid/#integrasi-numerik","text":"Metode Integrasi Numerik adalah salah satu cara untuk menghitung aproksimasi luas daerah di bawah fungsi yang dimaksud pada selang yang diberikan. Ada beberapa metode integrasi numerik yang lazim digunakan, diantaranya yaitu: Metode Euler Eksplisit Metode Euler Implisit pada metode integrasi implisit nilai aktual Xk juga digunakan sebagai umpan balik. Umpan balik ini dapat menyebabkan terjadinya lingkaran aljabar. untuk menghindarinya maka bentuk persamaan diubah menjadi seperti ini. METODE TRAPEZOID Aturan Trapezoid adalah suatu metode pendekatan integral numerik dengan polinomade satu. Metode trapezoid ini dapat diturunkan dengan substitusi fungsi Lagrange orde-1 sebagai f(x) yaitu: dengan demikian dapat dirumuskan: Dimana R adalah suku yang mengandung error komputasi O(h3). Sehingga kita mendapatkan rumus integral trapezoid yaitu: Dalam matematika , dan lebih khusus lagi dalam analisis numerik, aturan trapesium (juga dikenal sebagai Trapezoid Rule ) adalah teknik untuk mendekati integral yang pasti.","title":"INTEGRASI NUMERIK"},{"location":"RecrusiveTrapezoid/#estimasi-berdasarkan-1-interval","text":"","title":"Estimasi berdasarkan 1 Interval"},{"location":"RecrusiveTrapezoid/#algoritma-integral-trapezoida","text":"Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung Listing Program #definisi fungsi def fungsi (x): y = 1/(1+x) return y print(\"fungsi yang digunakan adalah\") print(\"\") print(\"\\t\\t\",\"f(x) = 1/(1+x)\") print(\"\") a = float(input(\"masukkan batas bawah integral : \")) b = float(input(\"masukkan batas atas integral : \")) c = int(input(\"masukkan n : \")) eror = [] print(\"\") print(\"----------------Hasil Integrasi-----------------\") print(\"iterasi\",\"\\t\",\"n\",\"\\t\\t\",\"Trapezoid\") for iterasi in range (0,c): n = 2**iterasi h = (b-a)/n xi = a y = 0 for i in range (1,n): xi = xi + h y += fungsi(xi) trap = ((h)*(fungsi(a) + (2*y) + fungsi(b)))/2 eror.append(trap) print (iterasi+1,\"\\t\\t\",n,\"\\t\\t\",trap) print (eror[iterasi-1]) print(eror[iterasi]) hasil = (eror[iterasi-1]-eror[iterasi]) print(hasil) print (\"estimasi error : \"+str(hasil)) \u200b hasil code fungsi yang digunakan adalah f(x) = 1/(1+x) masukkan batas bawah integral : 18 masukkan batas atas integral : 2 masukkan n : 10 ----------------Hasil Integrasi----------------- iterasi n Trapezoid 1 1 -3.087719298245614 2 2 -2.271132376395534 3 4 -1.9736614262930052 4 8 -1.880546148038408 5 16 -1.854757201003331 6 32 -1.8480774518918412 7 64 -1.846390566377457 8 128 -1.8459677344642065 9 256 -1.8458619561915175 10 512 -1.8458355072157113 -1.8458619561915175 -1.8458355072157113 -2.644897580617034e-05 estimasi error : -2.644897580617034e-05 \u200b","title":"Algoritma Integral Trapezoida"},{"location":"RichardsonExtrapolation/","text":"Richardson Extrapolation \u00b6 Dalam analisis numeril, Richard Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju kovergensi suatu urutan. Dinamai Lweis Fry Richardson, yang memperkenalkan teknik pada awal abad ke-20. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan diferensial biasa. Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2*n* dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc. Contoh Program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) Hasil Running \u00b6 f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Tugas 5"},{"location":"RichardsonExtrapolation/#richardson-extrapolation","text":"Dalam analisis numeril, Richard Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju kovergensi suatu urutan. Dinamai Lweis Fry Richardson, yang memperkenalkan teknik pada awal abad ke-20. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan diferensial biasa. Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2*n* dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc.","title":"Richardson Extrapolation"},{"location":"RichardsonExtrapolation/#contoh-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( 'f(x) = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( 'Hasil Diferensiasi Numerik= ' + ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 ))","title":"Contoh Program"},{"location":"RichardsonExtrapolation/#hasil-running","text":"f ( x ) = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 Hasil Diferensiasi Numerik = - 0.91250000000000530687 diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050","title":"Hasil Running"}]}