{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SELAMAT DATANG \u00b6 Nama : Pramintami Cahyaning S M Jurusan : Informatika Nim : 180411100011","title":"Beranda"},{"location":"#selamat-datang","text":"Nama : Pramintami Cahyaning S M Jurusan : Informatika Nim : 180411100011","title":"SELAMAT DATANG"},{"location":"DERETMacLaurin/","text":"DERET MacLaurin \u00b6 DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Atau bisa dinyatakan dengan: Perhitungan e^2x \u00b6 Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x)=exf(x)=ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e2xe2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99. Listing Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x=4 cek =1 a = 0 b=1 iter = 1 while cek>0.001: f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) cek = f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",cek) iter+=1 output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Tugas 1"},{"location":"DERETMacLaurin/#deret-maclaurin","text":"DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Atau bisa dinyatakan dengan:","title":"DERET MacLaurin"},{"location":"DERETMacLaurin/#perhitungan-e2x","text":"Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. f(x)=exf(x)=ex f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e2xe2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99.","title":"Perhitungan e^2x"},{"location":"DERETMacLaurin/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x=4 cek =1 a = 0 b=1 iter = 1 while cek>0.001: f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) cek = f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",cek) iter+=1 output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Listing Program"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/","text":"ELIMINASI GAUSS, GAUS JACOBI DAN GAUSS SEIDEL \u00b6 Eliminasi Gauss \u00b6 Eliminasi Gauss adalah algoritma yang digunakan untuk menyelesaikan sistem persamaan linier. Metode inni dinamai dari matematikawan Carl Friedrich Gauss(1777-1855).Metode ini dapat dimanfaatkan untuk memecahkan sistem persamaan linier dengan mempresentasikan (mengubah) menjadi bentuk matriks, matriks tersebut lalu diubah kebentuk Eselon Baris melalui Operasi Baris Elementer, kemudian sistem diselesaikan dengan substitusi balik. Terdapat tiga jenis operasi yang dapat dilakukan dalam metode ini: Mengganti urutan dua baris mengalikan baris dengan angka yang bukan nol menambah suatu baris dengan baris yang lainnya dengan cara ini, matriks dapat dirubah menjadi matriks segitiga atas. Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int(input(\"Tentukan ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen Matrix: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Substitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0 Eliminasi Gaus Jacobi \u00b6 Metode Jacobi adalah metode tak langsung atau metode iteratif yang melakukan permbaharuan nilai x yang diperoleh tiap iterasi(mirip metode substitusi berurutan). Metode ini merupakan suatu teknik penyelesaian SPL berukuran n*n, AX=b, secara iteratif. Proses penyelesaian dimuali dengan suatu hampiran awal terhadap penyelesain, Xo, kemudian membentuk suatu serangkaian vector X1,X2,... yang konvergen ke X.\\ Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterais jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nol nya besar. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167]) Eliminasi Gaus Seidel \u00b6 Metode Gauss-Seidel digunakan utnuk menyelesaikan sistem persamaan linier berukuran besar dan proporsi koefisien nol-nya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan presentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0]","title":"Tugas 3"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gauss-gaus-jacobi-dan-gauss-seidel","text":"","title":"ELIMINASI GAUSS, GAUS JACOBI DAN GAUSS SEIDEL"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gauss","text":"Eliminasi Gauss adalah algoritma yang digunakan untuk menyelesaikan sistem persamaan linier. Metode inni dinamai dari matematikawan Carl Friedrich Gauss(1777-1855).Metode ini dapat dimanfaatkan untuk memecahkan sistem persamaan linier dengan mempresentasikan (mengubah) menjadi bentuk matriks, matriks tersebut lalu diubah kebentuk Eselon Baris melalui Operasi Baris Elementer, kemudian sistem diselesaikan dengan substitusi balik. Terdapat tiga jenis operasi yang dapat dilakukan dalam metode ini: Mengganti urutan dua baris mengalikan baris dengan angka yang bukan nol menambah suatu baris dengan baris yang lainnya dengan cara ini, matriks dapat dirubah menjadi matriks segitiga atas. Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int(input(\"Tentukan ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen Matrix: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Substitusi x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output Tentukan ordo Matrix: 3 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: -3 Masukkan elemen Matrix: -1 Masukkan elemen Matrix: 2 Masukkan elemen Matrix: -2 Masukkan elemen Matrix: 1 Masukkan elemen Matrix: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 Matrix A : [[ 2. 1. -1. ] [ 0. 0.5 0.5] [ 0. 0. -1. ]] Nilai X 3 = -1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0","title":"Eliminasi Gauss"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gaus-jacobi","text":"Metode Jacobi adalah metode tak langsung atau metode iteratif yang melakukan permbaharuan nilai x yang diperoleh tiap iterasi(mirip metode substitusi berurutan). Metode ini merupakan suatu teknik penyelesaian SPL berukuran n*n, AX=b, secara iteratif. Proses penyelesaian dimuali dengan suatu hampiran awal terhadap penyelesain, Xo, kemudian membentuk suatu serangkaian vector X1,X2,... yang konvergen ke X.\\ Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode iterais jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nol nya besar. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan Ordo Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan elemen: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output Masukkan Ordo Matrix: 3 Masukkan elemen: 2 Masukkan elemen: 1 Masukkan elemen: -1 Masukkan elemen: -3 Masukkan elemen: -1 Masukkan elemen: 2 Masukkan elemen: -2 Masukkan elemen: 1 Masukkan elemen: 2 Masukkan Hasil: 8 Masukkan Hasil: -11 Masukkan Hasil: -3 A: array([[ 2., 1., -1.], [-3., -1., 2.], [-2., 1., 2.]]) b: array([ 8., -11., -3.]) x: array([34.89370728, 81.70007324, 4.78002167])","title":"Eliminasi Gaus Jacobi"},{"location":"EliminasiGauss%2CGaussJacobi%26GausSeidel/#eliminasi-gaus-seidel","text":"Metode Gauss-Seidel digunakan utnuk menyelesaikan sistem persamaan linier berukuran besar dan proporsi koefisien nol-nya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan presentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: -15 [0, 0, 0] [1.75, 3.5, -3.0] [3.375, 3.9375, -2.4375] [3.34375, 3.9921875, -2.4609375] [3.36328125, 3.9990234375, -2.4544921875] [3.36337890625, 3.9998779296875, -2.4546240234375] [3.36362548828125, 3.999984741210938, -2.4545467529296876] [3.363632873535156, 3.999998092651367, -2.454546469116211] [3.3636361404418946, 3.999999761581421, -2.4545454961395263] [3.363636314430237, 3.999999970197678, -2.454545468267441] [3.3636363596162795, 3.9999999962747097, -2.45454545540843] [3.363636362920785, 3.9999999995343387, -2.454545454738554] [3.363636363568223, 3.999999999941792, -2.454545454561069] [3.3636363636257154, 3.999999999992724, -2.4545454545482586] [3.3636363636352455, 3.9999999999990905, -2.4545454545457197] [3.3636363636362026, 3.9999999999998868, -2.4545454545454963] [3.3636363636363455, 3.999999999999986, -2.454545454545459] [3.363636363636361, 3.9999999999999982, -2.454545454545455] [3.3636363636363633, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] [3.3636363636363638, 4.0, -2.4545454545454546] Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0]","title":"Eliminasi Gaus Seidel"},{"location":"NewtonRaphson/","text":"Program Newton Raphson pada Fungsi Non Linear \u00b6 Newton Raphson \u00b6 adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Implementasi Pemrograman \u00b6 dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Tugas 2"},{"location":"NewtonRaphson/#program-newton-raphson-pada-fungsi-non-linear","text":"","title":"Program Newton Raphson pada Fungsi Non Linear"},{"location":"NewtonRaphson/#newton-raphson","text":"adalah metode pencarian akar suatu fungsi f(x) f(x) dengan pendekatan satu titik, dimana fungsi f(x) f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) y - f(x_0) = f'(x_0)(x - x_0) x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x 0 - f(x_0) = f'(x_0)(x - x_0) 0 - f(x_0) = f'(x_0)(x - x_0) y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) sehingga di dapat sebuah rumus : x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})}","title":"Newton Raphson"},{"location":"NewtonRaphson/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"NewtonRaphson/#implementasi-pemrograman","text":"dari algoritma diatas , kita dapat menyusun sebuah program seperti berikut. import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 4 * x )) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 4 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 20 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x - 4X f(x) = e^x - 4X maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x - 4 f'(x) = e^x - 4 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Implementasi Pemrograman"}]}